<!DOCTYPE html>
<html>
<head>
    <title>Quest VR Underwater Runner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; z-index: 100; }
        #vrButton { position: absolute; bottom: 20px; right: 20px; padding: 15px 25px; background: #ff6b35; color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; z-index: 100; }
        #vrButton:disabled { background: #666; cursor: not-allowed; }
        #instructions { position: absolute; bottom: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 100; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: white; padding: 40px; border-radius: 20px; text-align: center; display: none; z-index: 200; border: 3px solid #ff6b35; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>üêô Quest VR Underwater Runner</h3>
        <div>üí∞ Coins: <span id="coins">0</span></div>
        <div>üìè Distance: <span id="distance">0</span>m</div>
        <div>‚ö° Speed: <span id="speed">15</span> m/s</div>
    </div>
    
    <div id="instructions">
        <div>ü•Ω VR: Controllers to move & jump</div>
        <div>üíª Desktop: ‚Üê ‚Üí ‚Üë keys</div>
    </div>
    
    <button id="vrButton" disabled>Checking VR...</button>
    
    <div id="gameOver">
        <h1>üèÜ GAME COMPLETE!</h1>
        <div id="finalStats"></div>
        <button onclick="location.reload()">Play Again</button>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001122);
        scene.fog = new THREE.Fog(0x003366, 15, 60);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // VR Support Detection and Setup
        let vrSupported = false;
        let vrSession = null;
        
        async function checkVRSupport() {
            const vrButton = document.getElementById('vrButton');
            
            try {
                if (!navigator.xr) {
                    throw new Error('WebXR not available');
                }
                
                const supported = await navigator.xr.isSessionSupported('immersive-vr');
                if (supported) {
                    vrSupported = true;
                    vrButton.textContent = 'Enter VR';
                    vrButton.disabled = false;
                    vrButton.style.background = '#ff6b35';
                } else {
                    throw new Error('VR not supported');
                }
            } catch (error) {
                console.log('VR Check:', error.message);
                vrButton.textContent = 'VR Not Available';
                vrButton.style.background = '#666';
                
                // Show helpful message for Quest users
                if (error.message.includes('not available') || error.message.includes('not supported')) {
                    setTimeout(() => {
                        vrButton.textContent = 'Use Quest Browser';
                        vrButton.onclick = () => {
                            alert('For VR support:\n1. Use Oculus Browser on Quest\n2. Enable WebXR in browser settings\n3. Allow VR permissions');
                        };
                    }, 2000);
                }
            }
        }
        
        // VR Button Handler
        document.getElementById('vrButton').addEventListener('click', async () => {
            if (!vrSupported) return;
            
            try {
                if (renderer.xr.isPresenting) {
                    await vrSession.end();
                } else {
                    vrSession = await navigator.xr.requestSession('immersive-vr', {
                        requiredFeatures: ['local-floor'],
                        optionalFeatures: ['hand-tracking', 'bounded-floor']
                    });
                    
                    await renderer.xr.setSession(vrSession);
                    
                    vrSession.addEventListener('end', () => {
                        vrSession = null;
                        document.getElementById('vrButton').textContent = 'Enter VR';
                    });
                    
                    document.getElementById('vrButton').textContent = 'Exit VR';
                }
            } catch (error) {
                console.error('VR Session Error:', error);
                alert('VR Error: ' + error.message);
            }
        });
        
        // Initialize VR check
        checkVRSupport();
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x336699, 0.6);
        scene.add(ambientLight);
        
        const sunlight = new THREE.DirectionalLight(0x66AAFF, 1.5);
        sunlight.position.set(0, 30, 10);
        sunlight.castShadow = true;
        scene.add(sunlight);
        
        // Ocean floor
        const oceanFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(400, 400),
            new THREE.MeshLambertMaterial({ color: 0x8B7355 })
        );
        oceanFloor.rotation.x = -Math.PI / 2;
        scene.add(oceanFloor);
        
        // Animated bubbles
        const bubbles = [];
        for (let i = 0; i < 100; i++) {
            const bubble = new THREE.Mesh(
                new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 8, 6),
                new THREE.MeshBasicMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4 })
            );
            bubble.position.set(
                (Math.random() - 0.5) * 200,
                Math.random() * 15,
                (Math.random() - 0.5) * 200
            );
            bubble.userData = { riseSpeed: 0.5 + Math.random() * 1 };
            bubbles.push(bubble);
            scene.add(bubble);
        }
        
        // Swimming fish
        const fish = [];
        for (let i = 0; i < 50; i++) {
            const fishBody = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 6),
                new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
            );
            fishBody.scale.z = 2;
            fishBody.position.set(
                (Math.random() - 0.5) * 150,
                2 + Math.random() * 8,
                (Math.random() - 0.5) * 200
            );
            fishBody.userData = {
                speed: 1 + Math.random() * 2,
                direction: Math.random() * Math.PI * 2
            };
            fish.push(fishBody);
            scene.add(fishBody);
        }
        
        // Race lanes
        for (let i = -1; i <= 1; i++) {
            const lane = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.1, 600),
                new THREE.MeshBasicMaterial({ color: 0x66AAFF, transparent: true, opacity: 0.3 })
            );
            lane.position.set(i * 4, 0.2, 0);
            scene.add(lane);
        }
        
        // Player starfish
        const starfish = new THREE.Group();
        const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.8, 16, 12),
            new THREE.MeshStandardMaterial({ color: 0xFF6B35 })
        );
        body.scale.y = 0.4;
        starfish.add(body);
        
        // Starfish limbs
        const limbs = [];
        for (let i = 0; i < 5; i++) {
            const limb = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.15, 1.2, 8),
                new THREE.MeshStandardMaterial({ color: 0xFF6B35 })
            );
            const angle = (i / 5) * Math.PI * 2;
            limb.position.set(Math.cos(angle) * 0.6, -0.1, Math.sin(angle) * 0.6);
            limb.rotation.z = Math.PI / 2;
            limb.rotation.y = -angle;
            limbs.push(limb);
            starfish.add(limb);
        }
        
        starfish.position.set(0, 3, 0);
        scene.add(starfish);
        
        // VR Controllers
        const controller1 = renderer.xr.getController(0);
        const controller2 = renderer.xr.getController(1);
        scene.add(controller1);
        scene.add(controller2);
        
        // Game state
        let gameRunning = true;
        let starfishLane = 0;
        let starfishY = 3;
        let isJumping = false;
        let distance = 0;
        let coins = 0;
        let speed = 15;
        
        // Controller events
        controller1.addEventListener('selectstart', () => {
            if (gameRunning && starfishLane > -1) starfishLane--;
        });
        
        controller2.addEventListener('selectstart', () => {
            if (gameRunning && starfishLane < 1) starfishLane++;
        });
        
        controller1.addEventListener('squeezestart', () => {
            if (gameRunning && !isJumping) isJumping = true;
        });
        
        controller2.addEventListener('squeezestart', () => {
            if (gameRunning && !isJumping) isJumping = true;
        });
        
        // Objects
        const objects = [];
        
        function createCoin(x, z) {
            const coin = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 0.2, 8),
                new THREE.MeshBasicMaterial({ color: 0xFFD700 })
            );
            coin.position.set(x, 3, z);
            coin.userData = { type: 'coin', collected: false };
            objects.push(coin);
            scene.add(coin);
        }
        
        function createObstacle(x, z) {
            const obstacle = new THREE.Mesh(
                new THREE.BoxGeometry(2, 4, 1.5),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            obstacle.position.set(x, 2, z);
            obstacle.userData = { type: 'obstacle' };
            objects.push(obstacle);
            scene.add(obstacle);
        }
        
        // Generate level
        for (let z = -20; z > -400; z -= 10) {
            for (let lane = -1; lane <= 1; lane++) {
                if (Math.random() < 0.4) {
                    createCoin(lane * 4, z);
                }
            }
            if (Math.random() < 0.15) {
                const obsLane = [-1, 0, 1][Math.floor(Math.random() * 3)];
                createObstacle(obsLane * 4, z);
            }
        }
        
        // Desktop controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            if (e.code === 'ArrowLeft' && starfishLane > -1) starfishLane--;
            if (e.code === 'ArrowRight' && starfishLane < 1) starfishLane++;
            if (e.code === 'ArrowUp' && !isJumping) isJumping = true;
        });
        
        // Animation
        const clock = new THREE.Clock();
        
        function animate() {
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Animate environment
            bubbles.forEach(bubble => {
                bubble.position.y += bubble.userData.riseSpeed * deltaTime;
                if (bubble.position.y > 20) bubble.position.y = 0;
            });
            
            fish.forEach(fishBody => {
                fishBody.userData.direction += (Math.random() - 0.5) * 0.01;
                fishBody.position.x += Math.cos(fishBody.userData.direction) * fishBody.userData.speed * deltaTime;
                fishBody.position.z += Math.sin(fishBody.userData.direction) * fishBody.userData.speed * deltaTime;
                fishBody.rotation.y = fishBody.userData.direction;
            });
            
            if (gameRunning) {
                // Move starfish forward
                starfish.position.z -= speed * deltaTime;
                distance += speed * deltaTime;
                
                // Lane switching
                const targetX = starfishLane * 4;
                starfish.position.x += (targetX - starfish.position.x) * 0.1;
                
                // Jumping
                if (isJumping) {
                    starfishY += 8 * deltaTime;
                    if (starfishY > 6) {
                        starfishY = 6;
                        isJumping = false;
                    }
                } else {
                    starfishY += (3 - starfishY) * 0.1;
                }
                starfish.position.y = starfishY;
                
                // Starfish animation
                starfish.rotation.y = Math.sin(time * 4) * 0.3;
                limbs.forEach((limb, i) => {
                    limb.rotation.x = Math.sin(time * 5 + i) * 0.4;
                });
                
                // Coin animation
                objects.forEach(obj => {
                    if (obj.userData.type === 'coin') {
                        obj.rotation.y += deltaTime * 3;
                    }
                });
                
                // Collision detection
                objects.forEach(obj => {
                    const dx = Math.abs(starfish.position.x - obj.position.x);
                    const dy = Math.abs(starfish.position.y - obj.position.y);
                    const dz = Math.abs(starfish.position.z - obj.position.z);
                    
                    if (dx < 1.5 && dy < 1.5 && dz < 2) {
                        if (obj.userData.type === 'coin' && !obj.userData.collected) {
                            obj.userData.collected = true;
                            obj.visible = false;
                            coins++;
                            speed += 0.1;
                        } else if (obj.userData.type === 'obstacle') {
                            gameRunning = false;
                            document.getElementById('finalStats').innerHTML = `
                                <div>üèÉ Distance: <strong>${Math.floor(distance)}m</strong></div>
                                <div>üí∞ Coins: <strong>${coins}</strong></div>
                                <div>üèÜ Score: <strong>${coins * 10 + Math.floor(distance)}</strong></div>
                            `;
                            document.getElementById('gameOver').style.display = 'block';
                        }
                    }
                });
                
                // Camera follow
                if (renderer.xr.isPresenting) {
                    // VR camera positioning
                    camera.position.z = starfish.position.z + 3;
                    camera.position.x = starfish.position.x * 0.1;
                } else {
                    // Desktop camera
                    camera.position.z = starfish.position.z + 6;
                    camera.position.x = starfish.position.x * 0.2;
                    camera.lookAt(starfish.position);
                }
                
                // Update UI
                document.getElementById('coins').textContent = coins;
                document.getElementById('distance').textContent = Math.floor(distance);
                document.getElementById('speed').textContent = speed.toFixed(1);
            }
            
            renderer.render(scene, camera);
        }
        
        renderer.setAnimationLoop(animate);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        console.log('üêô Quest VR Underwater Runner ready!');
    </script>
</body>
</html>