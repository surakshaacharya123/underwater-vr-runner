<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kev the Annoyer - 3D Destruction Simulation</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover { background: #ff8c42; }
        button:disabled { background: #666; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="info">
        <h3>üêô Kev the Annoyer</h3>
        <p>Click "SMASH!" or press SPACE to trigger destruction</p>
        <p>Use mouse to orbit camera</p>
    </div>
    
    <div id="controls">
        <button id="smashBtn">SMASH!</button>
        <button id="resetBtn">Reset</button>
        <button id="vrBtn" style="display:none;">Enter VR</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Simple mouse controls
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.add(groundBody);

        // Starfish creation
        function createStarfish() {
            const group = new THREE.Group();
            
            // Main body
            const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 12);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff6b35,
                roughness: 0.7,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.y = 0.6;
            body.castShadow = true;
            group.add(body);

            // Five limbs
            const limbGeometry = new THREE.CylinderGeometry(0.15, 0.25, 1.5, 8);
            const limbs = [];
            
            for (let i = 0; i < 5; i++) {
                const limb = new THREE.Mesh(limbGeometry, bodyMaterial.clone());
                const angle = (i / 5) * Math.PI * 2;
                limb.position.set(Math.cos(angle) * 0.8, -0.2, Math.sin(angle) * 0.8);
                limb.rotation.z = Math.PI / 2;
                limb.rotation.y = -angle;
                limb.castShadow = true;
                limbs.push(limb);
                group.add(limb);
            }

            // Eye
            const eyeGeometry = new THREE.SphereGeometry(0.15, 12, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eye.position.set(0, 0.2, 0.6);
            eye.castShadow = true;
            group.add(eye);

            // Pupil
            const pupilGeometry = new THREE.SphereGeometry(0.08, 8, 6);
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupil.position.set(0, 0.22, 0.68);
            group.add(pupil);

            group.position.set(-8, 2, 0);
            group.userData = { limbs, originalY: 2 };
            return group;
        }

        // Building creation
        function createBuilding() {
            const buildingGroup = new THREE.Group();
            const blocks = [];
            const bodies = [];

            const blockMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const blockShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.25, 0.5));

            // Create building blocks
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 4; x++) {
                    for (let z = 0; z < 4; z++) {
                        const blockGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                        const block = new THREE.Mesh(blockGeometry, blockMaterial.clone());
                        
                        block.position.set(x - 1.5, y * 0.5 + 0.25, z - 1.5);
                        block.castShadow = true;
                        block.receiveShadow = true;
                        
                        const blockBody = new CANNON.Body({ mass: 1 });
                        blockBody.addShape(blockShape);
                        blockBody.position.copy(block.position);
                        
                        blocks.push(block);
                        bodies.push(blockBody);
                        buildingGroup.add(block);
                        world.add(blockBody);
                    }
                }
            }

            buildingGroup.position.set(2, 0, 0);
            buildingGroup.userData = { blocks, bodies };
            return buildingGroup;
        }

        // Particle system for debris and smoke
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            createExplosion(position, count = 50) {
                for (let i = 0; i < count; i++) {
                    const geometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 4, 4);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(0.1, 0.7, 0.3 + Math.random() * 0.4),
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    particle.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    ));
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 10,
                            Math.random() * 8 + 2,
                            (Math.random() - 0.5) * 10
                        ),
                        life: 1.0,
                        decay: 0.5 + Math.random() * 0.5
                    };
                    
                    this.particles.push(particle);
                    scene.add(particle);
                }
            }

            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    const userData = particle.userData;
                    
                    // Update position
                    particle.position.add(userData.velocity.clone().multiplyScalar(deltaTime));
                    userData.velocity.y -= 9.82 * deltaTime; // Gravity
                    
                    // Update life
                    userData.life -= userData.decay * deltaTime;
                    particle.material.opacity = userData.life;
                    
                    // Remove dead particles
                    if (userData.life <= 0 || particle.position.y < -5) {
                        scene.remove(particle);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        // Initialize objects
        const starfish = createStarfish();
        const building = createBuilding();
        const particleSystem = new ParticleSystem();
        
        scene.add(starfish);
        scene.add(building);

        // Animation state
        let isSmashing = false;
        let hasSmashed = false;
        const clock = new THREE.Clock();

        // Starfish animation
        function animateStarfish() {
            const time = clock.getElapsedTime();
            
            // Breathing animation
            starfish.scale.y = 1 + Math.sin(time * 2) * 0.05;
            
            // Limb animation
            if (starfish.userData.limbs) {
                starfish.userData.limbs.forEach((limb, index) => {
                    limb.rotation.x = Math.sin(time * 3 + index) * 0.2;
                });
            }
            
            // Floating animation
            if (!isSmashing) {
                starfish.position.y = starfish.userData.originalY + Math.sin(time * 1.5) * 0.3;
            }
        }

        // Smash animation
        function triggerSmash() {
            if (isSmashing || hasSmashed) return;
            
            isSmashing = true;
            hasSmashed = true;
            
            // Animate starfish movement
            gsap.to(starfish.position, {
                duration: 2,
                x: 2,
                y: 1,
                z: 0,
                ease: "power2.inOut",
                onComplete: () => {
                    // Impact!
                    particleSystem.createExplosion(new THREE.Vector3(2, 2, 0), 100);
                    
                    // Apply forces to building blocks
                    building.userData.bodies.forEach((body, index) => {
                        const force = new CANNON.Vec3(
                            (Math.random() - 0.5) * 500,
                            Math.random() * 300 + 100,
                            (Math.random() - 0.5) * 500
                        );
                        body.applyImpulse(force, body.position);
                    });
                    
                    // Camera shake
                    gsap.to(camera.position, {
                        duration: 0.5,
                        x: camera.position.x + (Math.random() - 0.5) * 2,
                        y: camera.position.y + (Math.random() - 0.5) * 2,
                        z: camera.position.z + (Math.random() - 0.5) * 2,
                        ease: "power2.out"
                    });
                    
                    isSmashing = false;
                }
            });
            
            // Starfish rotation during smash
            gsap.to(starfish.rotation, {
                duration: 2,
                x: Math.PI * 2,
                ease: "power2.inOut"
            });
        }

        // Reset function
        function resetScene() {
            hasSmashed = false;
            isSmashing = false;
            
            // Reset starfish
            gsap.to(starfish.position, {
                duration: 1,
                x: -8,
                y: 2,
                z: 0
            });
            gsap.to(starfish.rotation, {
                duration: 1,
                x: 0,
                y: 0,
                z: 0
            });
            
            // Reset building
            building.userData.bodies.forEach((body, index) => {
                const block = building.userData.blocks[index];
                const originalPos = new THREE.Vector3(
                    (index % 16) % 4 - 1.5,
                    Math.floor((index % 64) / 16) * 0.5 + 0.25,
                    Math.floor(index / 16) - 1.5
                );
                
                body.position.copy(originalPos);
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
                body.quaternion.set(0, 0, 0, 1);
            });
            
            // Clear particles
            particleSystem.particles.forEach(particle => scene.remove(particle));
            particleSystem.particles = [];
        }

        // WebXR setup
        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                if (supported) {
                    const vrButton = document.getElementById('vrBtn');
                    vrButton.style.display = 'block';
                    vrButton.addEventListener('click', () => {
                        if (renderer.xr.isPresenting) {
                            renderer.xr.getSession().end();
                        } else {
                            navigator.xr.requestSession('immersive-vr').then((session) => {
                                renderer.xr.setSession(session);
                            });
                        }
                    });
                }
            });
        }

        // Event listeners
        document.getElementById('smashBtn').addEventListener('click', triggerSmash);
        document.getElementById('resetBtn').addEventListener('click', resetScene);

        window.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                triggerSmash();
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            renderer.setAnimationLoop(() => {
                const deltaTime = clock.getDelta();
                
                // Update physics
                world.step(deltaTime);
                
                // Sync Three.js objects with physics bodies
                building.userData.bodies.forEach((body, index) => {
                    const block = building.userData.blocks[index];
                    block.position.copy(body.position);
                    block.quaternion.copy(body.quaternion);
                });
                
                // Update animations
                animateStarfish();
                particleSystem.update(deltaTime);
                
                // Update controls
                controls.update();
                
                // Render
                renderer.render(scene, camera);
            });
        }

        // Start animation
        animate();

        console.log('üêô Kev the Annoyer loaded! Press SPACE or click SMASH to destroy the building!');
    </script>
</body>
</html>