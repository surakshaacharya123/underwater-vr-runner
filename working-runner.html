<!DOCTYPE html>
<html>
<head>
    <title>Starfish Runner - Working Version</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; }
        button { position: absolute; bottom: 20px; left: 20px; padding: 10px 20px; background: #ff6b35; color: white; border: none; border-radius: 5px; cursor: pointer; }
        #gameOver {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: white; padding: 40px; border-radius: 20px;
            text-align: center; display: none; z-index: 200; border: 3px solid #ff6b35;
        }
        #gameOver h1 { color: #ff6b35; margin-bottom: 20px; }
        #gameOver button { position: static; margin: 10px; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>🐙 Starfish Runner</h3>
        <div>💰 Coins: <span id="coins">0</span></div>
        <div>📏 Distance: <span id="distance">0</span>m</div>
        <div>⚡ Speed: <span id="speed">15</span> m/s</div>
        <div><small>← → to change lanes, ↑ to jump</small></div>
    </div>
    
    <button onclick="location.reload()">RESTART</button>
    
    <div id="gameOver">
        <h1>💥 GAME OVER!</h1>
        <div id="finalStats"></div>
        <button onclick="location.reload()">Play Again</button>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x006994);
        scene.fog = new THREE.Fog(0x006994, 30, 100);
        
        // Add floating bubbles
        const bubbles = [];
        for (let i = 0; i < 80; i++) {
            const bubble = new THREE.Mesh(
                new THREE.SphereGeometry(0.1 + Math.random() * 0.3, 8, 6),
                new THREE.MeshBasicMaterial({ 
                    color: 0x87CEEB, 
                    transparent: true, 
                    opacity: 0.4 
                })
            );
            bubble.position.set(
                (Math.random() - 0.5) * 200,
                Math.random() * 15 + 1,
                (Math.random() - 0.5) * 600
            );
            bubbles.push(bubble);
            scene.add(bubble);
        }
        
        // Add swimming fish
        const fish = [];
        for (let i = 0; i < 40; i++) {
            const fishBody = new THREE.Mesh(
                new THREE.SphereGeometry(0.2 + Math.random() * 0.2, 8, 6),
                new THREE.MeshStandardMaterial({ 
                    color: [0xff6600, 0x00ff66, 0x6600ff, 0xffff00][Math.floor(Math.random() * 4)]
                })
            );
            fishBody.scale.z = 1.8;
            fishBody.position.set(
                (Math.random() - 0.5) * 150,
                1 + Math.random() * 10,
                (Math.random() - 0.5) * 600
            );
            fish.push(fishBody);
            scene.add(fishBody);
        }
        
        // Add sea plants
        for (let i = 0; i < 60; i++) {
            const plant = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.15, 1 + Math.random() * 4, 6),
                new THREE.MeshStandardMaterial({ color: 0x228B22 })
            );
            plant.position.set(
                (Math.random() - 0.5) * 200,
                plant.geometry.parameters.height / 2,
                (Math.random() - 0.5) * 600
            );
            scene.add(plant);
        }
        
        // Add coral decorations
        for (let i = 0; i < 25; i++) {
            const coral = new THREE.Mesh(
                new THREE.SphereGeometry(0.3 + Math.random() * 0.7, 8, 6),
                new THREE.MeshStandardMaterial({ 
                    color: [0xff69b4, 0xff1493, 0xffa500, 0x9370db][Math.floor(Math.random() * 4)]
                })
            );
            coral.position.set(
                (Math.random() - 0.5) * 180,
                0.3,
                (Math.random() - 0.5) * 600
            );
            scene.add(coral);
        }
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 8);
        
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        scene.add(new THREE.DirectionalLight(0xffffff, 1));
        scene.add(new THREE.AmbientLight(0x404040, 0.6));
        
        // Ground
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshLambertMaterial({ color: 0x8B7355 })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        
        // Lane markers
        for (let i = -1; i <= 1; i++) {
            const lane = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.1, 200),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            lane.position.set(i * 3, 0.05, 0);
            scene.add(lane);
        }
        
        // Finish line - make distance longer
        const finishZ = -500;
        const banner = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 3),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        banner.position.set(0, 4, finishZ);
        scene.add(banner);
        
        for (let i = -1; i <= 1; i++) {
            const post = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 6, 8),
                new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            post.position.set(i * 5, 3, finishZ);
            scene.add(post);
        }
        
        // Starfish
        const starfish = new THREE.Group();
        const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 12),
            new THREE.MeshStandardMaterial({ color: 0xff6b35 })
        );
        body.scale.y = 0.6;
        starfish.add(body);
        
        for (let i = 0; i < 5; i++) {
            const limb = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.15, 1, 8),
                new THREE.MeshStandardMaterial({ color: 0xff6b35 })
            );
            const angle = (i / 5) * Math.PI * 2;
            limb.position.set(Math.cos(angle) * 0.5, -0.1, Math.sin(angle) * 0.5);
            limb.rotation.z = Math.PI / 2;
            limb.rotation.y = -angle;
            starfish.add(limb);
        }
        
        const eye = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 12, 8),
            new THREE.MeshStandardMaterial({ color: 0x000000 })
        );
        eye.position.set(0, 0.2, 0.4);
        starfish.add(eye);
        
        starfish.position.set(0, 1.5, 0);
        scene.add(starfish);
        
        // Game state
        let gameRunning = true;
        let celebrating = false;
        let gameTime = 0;
        let starfishLane = 0;
        let starfishY = 1.5;
        let isJumping = false;
        let distance = 0;
        let coins = 0;
        let speed = 15;
        
        // Objects
        const objects = [];
        const debris = [];
        
        function createCoin(x, z) {
            const coin = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 0.2, 8),
                new THREE.MeshBasicMaterial({ color: 0xFFD700 })
            );
            coin.position.set(x, 1.5, z);
            coin.userData = { type: 'coin', collected: false };
            objects.push(coin);
            scene.add(coin);
        }
        
        function createObstacle(x, z) {
            const obstacle = new THREE.Mesh(
                new THREE.BoxGeometry(2, 3, 1),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            obstacle.position.set(x, 1.5, z);
            obstacle.userData = { type: 'obstacle', destroyed: false };
            objects.push(obstacle);
            scene.add(obstacle);
        }
        
        function destroyObstacle(obstacle) {
            if (obstacle.userData.destroyed) return;
            obstacle.userData.destroyed = true;
            obstacle.visible = false;
            
            for (let i = 0; i < 15; i++) {
                const piece = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.3, 0.3),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                );
                piece.position.copy(obstacle.position);
                piece.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ));
                piece.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        Math.random() * 0.2 + 0.1,
                        (Math.random() - 0.5) * 0.3
                    )
                };
                debris.push(piece);
                scene.add(piece);
            }
        }
        
        function gameOver() {
            gameRunning = false;
            const finalDistance = Math.floor(Math.abs(starfish.position.z));
            const totalScore = coins * 10 + Math.floor(finalDistance / 10);
            
            document.getElementById('finalStats').innerHTML = `
                <div style="font-size: 18px; margin: 15px 0;">
                    <div>🏃 Distance: <strong>${finalDistance}m</strong></div>
                    <div>💰 Coins: <strong>${coins}</strong></div>
                    <div>⚡ Speed: <strong>${speed.toFixed(1)} m/s</strong></div>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(255,107,53,0.2); border-radius: 10px;">
                        🏆 Score: <strong style="color: #FFD700; font-size: 24px;">${totalScore} points</strong>
                    </div>
                </div>
            `;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function gameWon() {
            gameRunning = false;
            celebrating = true;
            const finalDistance = Math.floor(Math.abs(starfish.position.z));
            const timeBonus = Math.max(0, 1000 - Math.floor(gameTime * 10));
            const totalScore = coins * 20 + timeBonus + 500;
            
            document.getElementById('gameOver').innerHTML = `
                <h1>🏆 VICTORY!</h1>
                <div style="font-size: 18px; margin: 15px 0;">
                    <div>🎉 You reached the finish line!</div>
                    <div>🏃 Distance: <strong>${finalDistance}m</strong></div>
                    <div>💰 Coins: <strong>${coins}</strong></div>
                    <div>⚡ Speed: <strong>${speed.toFixed(1)} m/s</strong></div>
                    <div>⏱️ Time Bonus: <strong>${timeBonus}</strong></div>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(255,215,0,0.3); border-radius: 10px;">
                        🏆 CHAMPION SCORE: <strong style="color: #FFD700; font-size: 24px;">${totalScore} points</strong>
                    </div>
                </div>
                <button onclick="location.reload()">Race Again</button>
            `;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // Generate level
        for (let z = -20; z > finishZ + 10; z -= 8) {
            for (let lane = -1; lane <= 1; lane++) {
                if (Math.random() < 0.7) {
                    createCoin(lane * 3, z);
                }
            }
            if (Math.random() < 0.3) {
                const obsLane = [-1, 0, 1][Math.floor(Math.random() * 3)];
                createObstacle(obsLane * 3, z);
            }
        }
        
        // Controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            if (e.code === 'ArrowLeft' && starfishLane > -1) {
                starfishLane--;
            }
            if (e.code === 'ArrowRight' && starfishLane < 1) {
                starfishLane++;
            }
            if (e.code === 'ArrowUp' && !isJumping) {
                isJumping = true;
            }
        });
        
        // Animation
        const clock = new THREE.Clock();
        
        function animate() {
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();
            
            if (gameRunning) {
                starfish.position.z -= speed * deltaTime;
                distance += speed * deltaTime;
                gameTime += deltaTime;
                
                // Animate bubbles
                bubbles.forEach(bubble => {
                    bubble.position.y += 0.5 * deltaTime;
                    bubble.rotation.x += deltaTime;
                    if (bubble.position.y > 15) {
                        bubble.position.y = 0;
                    }
                });
                
                // Animate fish swimming
                fish.forEach((fishBody, index) => {
                    fishBody.position.x += Math.sin(time + index) * 0.02;
                    fishBody.position.y += Math.cos(time * 2 + index) * 0.01;
                    fishBody.rotation.y = Math.sin(time + index) * 0.3;
                });
                
                const targetX = starfishLane * 3;
                starfish.position.x += (targetX - starfish.position.x) * 0.2;
                
                if (isJumping) {
                    starfishY += 15 * deltaTime;
                    if (starfishY > 4) {
                        starfishY = 4;
                        isJumping = false;
                    }
                } else {
                    starfishY += (1.5 - starfishY) * 0.2;
                }
                starfish.position.y = starfishY;
                
                starfish.rotation.y = Math.sin(time * 8) * 0.2;
                starfish.children.forEach((child, i) => {
                    if (i > 0 && i < 6) {
                        child.rotation.x = Math.sin(time * 10 + i) * 0.3;
                    }
                });
                
                objects.forEach(obj => {
                    if (obj.userData.type === 'coin') {
                        obj.rotation.y += deltaTime * 5;
                    }
                });
                
                objects.forEach(obj => {
                    const dx = Math.abs(starfish.position.x - obj.position.x);
                    const dy = Math.abs(starfish.position.y - obj.position.y);
                    const dz = Math.abs(starfish.position.z - obj.position.z);
                    
                    if (dx < 1 && dy < 1 && dz < 2) {
                        if (obj.userData.type === 'coin' && !obj.userData.collected) {
                            obj.userData.collected = true;
                            obj.visible = false;
                            coins++;
                            speed += 0.5;
                        } else if (obj.userData.type === 'obstacle' && !obj.userData.destroyed) {
                            destroyObstacle(obj);
                            gameOver();
                        }
                    }
                });
                
                if (starfish.position.z <= finishZ) {
                    gameWon();
                }
                
                camera.position.z = starfish.position.z + 8;
                camera.position.x = starfish.position.x * 0.3;
                camera.lookAt(starfish.position.x, starfish.position.y, starfish.position.z);
                
                document.getElementById('coins').textContent = coins;
                document.getElementById('distance').textContent = Math.floor(Math.abs(starfish.position.z));
                document.getElementById('speed').textContent = speed.toFixed(1);
            }
            
            if (celebrating) {
                starfish.position.y = 1.5 + Math.sin(time * 15) * 0.5;
                starfish.rotation.y = time * 3;
                starfish.children.forEach((child, i) => {
                    if (i > 0 && i < 6) {
                        child.rotation.x = Math.sin(time * 20 + i) * 0.8;
                    }
                });
            }
            
            debris.forEach((piece, index) => {
                piece.userData.velocity.y -= 0.01;
                piece.position.add(piece.userData.velocity);
                piece.rotation.x += 0.05;
                piece.rotation.z += 0.03;
                
                if (piece.position.y < -5) {
                    scene.remove(piece);
                    debris.splice(index, 1);
                }
            });
            
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        
        animate();
        
        console.log('🐙 Starfish Runner! ← → to change lanes, ↑ to jump');
    </script>
</body>
</html>